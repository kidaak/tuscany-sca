/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
package org.apache.tuscany.sca.binding.rmi.provider;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.rmi.Remote;

import org.apache.tuscany.sca.host.rmi.RMIHost;
import org.apache.tuscany.sca.interfacedef.Operation;
import org.apache.tuscany.sca.interfacedef.java.impl.JavaInterfaceUtil;
import org.apache.tuscany.sca.invocation.DataExchangeSemantics;
import org.apache.tuscany.sca.invocation.Invoker;
import org.apache.tuscany.sca.invocation.Message;

/**
 * Invoker for RMI References.
 * 
 * When invoke is fire, the Service Interface can be Conversational or not, when
 * Service Interface is conversational, so the Conversational Service Interface
 * is created and loaded. Conversational Service Interface is responsable to
 * carry conversationId to server side.
 * 
 * @version $Rev$ $Date$
 */
public class RMIBindingInvoker implements Invoker, DataExchangeSemantics {

	private RMIHost rmiHost;
	private String uri;
	private Method referenceMethod;
	private Remote proxy;
	private Class<?> serviceInterface;

	public RMIBindingInvoker(RMIHost rmiHost, String uri,
			Class<?> serviceInterface, Operation operation) {
		this.rmiHost = rmiHost;
		this.uri = uri;
		this.serviceInterface = serviceInterface;
		try {
			this.referenceMethod = JavaInterfaceUtil.findMethod(
					serviceInterface, operation);
		} catch (NoSuchMethodException e) {
			throw new IllegalArgumentException(e);
		}
		;
	}

	public Message invoke(Message msg) {
		try {
			Object conversationId = msg.getFrom().getReferenceParameters().getConversationID();
			boolean isConversational = conversationId != null;
			Object resp;
			if (isConversational) {
				initProxy(serviceInterface, true);
				resp = invokeConversational(conversationId, msg.getBody());
			} else {
				initProxy(serviceInterface, false);
				resp = invokeTarget(msg.getBody());
			}
			msg.setBody(resp);
		} catch (InvocationTargetException e) {
			Throwable cause = getCause(e);
			if (cause == null) {
				cause = e.getCause();
			}
			msg.setFaultBody(cause);
		} catch (Throwable e) {
			msg.setFaultBody(e);
		}
		return msg;
	}

	/**
	 * Find Remote Service
	 * 
	 * If Service Interface is conversational the Conversational Service
	 * Interface is created and loaded, this is necessary because RMI looking
	 * for Conversational Service Interface in client side, when any method in
	 * conversational service interface is called.
	 * 
	 * @param serviceInterface
	 *            The Service Interface
	 * @param isConversational
	 *            Indicate if Service Interface is Conversational.
	 */
	private void initProxy(Class<?> serviceInterface, boolean isConversational) {
		if (proxy == null) {
			if (isConversational) {
				ConversationalServiceInterfaceFactory.create(serviceInterface);
			}
			proxy = rmiHost.findService(uri);
		}
	}

	/**
	 * Get the original throwable.
	 * 
	 * If throwable was throws by Service Interface, than original throwable is
	 * returned, else null is returned.
	 * 
	 * @param e The final Throwable
	 * @return The Original Throwable or null
	 */
	private Throwable getCause(Throwable e) {
		Throwable cause = e.getCause();
		Throwable expectedCause = null;
		for (Class<?> declaredType : referenceMethod.getExceptionTypes()) {
			if (declaredType.isInstance(cause)) {
				expectedCause = cause;
				break;
			}
		}
		if (expectedCause == null) {
			expectedCause = getCause(cause);
		}
		return expectedCause;
	}

	/**
	 * Invoke the Method in Conversational Service Interface. This method verify
	 * the parameters of reference method and create a new argument, that take the
	 * conversationId.
	 * 
	 * @param conversationId
	 *            The ConversationId generated by SCA
	 * @param args
	 *            The parameters of Method of Service Interface
	 * @return The result of Method executed.
	 * @throws InvocationTargetException
	 * @throws SecurityException
	 * @throws NoSuchMethodException
	 * @throws IllegalArgumentException
	 * @throws IllegalAccessException
	 */
	private Object invokeConversational(Object conversationId, Object args)
			throws InvocationTargetException, SecurityException,
			NoSuchMethodException, IllegalArgumentException,
			IllegalAccessException {
		Object[] newParameters = null;
		Class<?>[] newParametersType = null;
		if (isWithoutParameters(args)) {
			newParameters = new Object[1];
			newParametersType = new Class[1];
		} else {
			Object[] parameters = (Object[]) args;
			newParameters = new Object[parameters.length + 1];
			System.arraycopy(args, 0, newParameters, 0, parameters.length);
			Class<?>[] refParameters = referenceMethod.getParameterTypes();
			newParametersType = new Class[refParameters.length + 1];
			System.arraycopy(refParameters, 0, newParametersType, 0, refParameters.length);
		}
		newParameters[newParameters.length - 1] = new ConversationalParameter(conversationId);
		newParametersType[newParametersType.length - 1] = ConversationalParameter.class;
		Method conversationalMethod = proxy.getClass().getMethod(referenceMethod.getName(), newParametersType);
		return invoke(conversationalMethod, proxy, newParameters);
	}

	/**
	 * Invoke the Method in Service Interface
	 * 
	 * @param parameters
	 *            The parameters of Method of Service Interface
	 * @return The result of Method executed.
	 * @throws InvocationTargetException
	 * @throws SecurityException
	 * @throws NoSuchMethodException
	 * @throws IllegalArgumentException
	 * @throws IllegalAccessException
	 */
	private Object invokeTarget(final Object parameters)
			throws InvocationTargetException, SecurityException,
			NoSuchMethodException, IllegalArgumentException,
			IllegalAccessException {
		
		Method remoteMethod = proxy.getClass().getMethod(referenceMethod.getName(), referenceMethod.getParameterTypes());
		return invoke(remoteMethod, proxy, parameters);
	}

	private Object invoke(Method remoteMethod, Remote proxy,
			final Object parameters) throws InvocationTargetException,
			SecurityException, NoSuchMethodException, IllegalArgumentException,
			IllegalAccessException {
		
		if (parameters != null && !parameters.getClass().isArray()) {
			return remoteMethod.invoke(proxy, parameters);
		} else {
			return remoteMethod.invoke(proxy, (Object[]) parameters);
		}
	}

	public boolean allowsPassByReference() {
		// RMI always pass by value
		return true;
	}

	private boolean isWithoutParameters(Object parameters) {
		return (parameters == null || (parameters.getClass().isArray() && ((Object[]) parameters).length == 0));
	}
}
